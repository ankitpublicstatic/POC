S - Single-responsibility Principle
O - Open-closed Principle
L - Liskov Substitution Principle
I - Interface Segregation Principle
D - Dependency Inversion Principle

SOLID is a set of five object-oriented design principles that help you write software that is:

Easy to understand
Easy to maintain
Flexible to change
Testable and scalable

They were popularized by Robert C. Martin (Uncle Bob).

Letâ€™s break them down simply with examples.

---

# âœ… S â€” Single Responsibility Principle (SRP)

> A class should have only one reason to change.

Meaning: one class = one job.

### âŒ Bad

```java
class UserService {
    void saveUser() { /save to DB */ }
    void sendEmail() { /send email */ }
}
```

This class handles DB + email â†’ two responsibilities.

### âœ… Good

```java
class UserRepository {
    void saveUser() {}
}

class EmailService {
    void sendEmail() {}
}
```

ğŸ‘‰ If email logic changes, DB code is safe.

---

# âœ… O â€” Open/Closed Principle (OCP)

> Open for extension, closed for modification.

You should add new behavior without changing old code.

### âŒ Bad

```java
class Discount {
    double calculate(String type) {
        if (type.equals("NEW")) return 10;
        if (type.equals("VIP")) return 20;
        return 0;
    }
}
```

Every new type = modify code.

### âœ… Good

```java
interface Discount {
    double calculate();
}

class NewCustomerDiscount implements Discount {
    public double calculate() { return 10; }
}

class VipDiscount implements Discount {
    public double calculate() { return 20; }
}
```

ğŸ‘‰ Add new discounts without touching old classes.

---

# âœ… L â€” Liskov Substitution Principle (LSP)

> Subclasses must be replaceable for their base classes.

If class B extends class A, B should behave like A.

### âŒ Bad

```java
class Bird {
    void fly() {}
}

class Ostrich extends Bird {
    void fly() { throw new UnsupportedOperationException(); }
}
```

Ostrich canâ€™t fly â†’ breaks expectations.

### âœ… Good

```java
class Bird {}

interface FlyingBird {
    void fly();
}
```

ğŸ‘‰ Only flying birds implement fly.

---

# âœ… I â€” Interface Segregation Principle (ISP)

> Donâ€™t force classes to implement methods they donâ€™t use.

### âŒ Bad

```java
interface Worker {
    void work();
    void eat();
}
```

Robot doesnâ€™t eat!

### âœ… Good

```java
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}
```

ğŸ‘‰ Classes implement only what they need.

---

# âœ… D â€” Dependency Inversion Principle (DIP)

> Depend on abstractions, not concrete classes.

### âŒ Bad

```java
class OrderService {
    MySQLDatabase db = new MySQLDatabase();
}
```

Hard-coded dependency.

### âœ… Good

```java
interface Database {
    void save();
}

class OrderService {
    Database db;
    OrderService(Database db) {
        this.db = db;
    }
}
```

ğŸ‘‰ You can switch DB easily (MySQL â†’ MongoDB).

---

# ğŸš€ Why SOLID Matters (Real-World Impact)

Using SOLID helps you:

âœ” Reduce bugs
âœ” Improve code readability
âœ” Make testing easier
âœ” Support scalability
âœ” Enable team collaboration
âœ” Refactor safely

---

# ğŸ¯ Interview-Ready Summary

> SOLID is a set of five design principles that make object-oriented code maintainable, scalable, and flexible. They promote loose coupling, high cohesion, and abstraction.

---

If you want, I can next:

âœ… Show real-world Spring Boot examples
âœ… Show SOLID violations in production code
âœ… Give interview questions + answers on SOLID
âœ… Provide Node.js/Express SOLID examples

Just tell me ğŸ‘
