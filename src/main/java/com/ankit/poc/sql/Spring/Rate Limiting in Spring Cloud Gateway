Below is a full, end-to-end, production-grade explanation of Rate Limiting in Spring Cloud Gateway (SCG) â€” from why it exists â†’ internal architecture â†’ exact implementation steps â†’ real production pitfalls.

Iâ€™ll explain it as if you were building a Zepto-scale API Gateway.

---

# 1ï¸âƒ£ What is Rate Limiting (Conceptually)

Rate limiting = controlling how many requests a client can make in a given time window

Examples:

 100 requests / minute / user
 10 requests / second / IP
 5 checkout requests / minute

### Why itâ€™s mandatory

Without rate limiting:

 âŒ DDoS can kill your system
 âŒ One bad client can exhaust threads
 âŒ Downstream services get overloaded
 âŒ Retry storms amplify failures

---

# 2ï¸âƒ£ Where Rate Limiting Lives in Microservices

### Correct placement

```
Client
  â†“
API Gateway  â†â”€â”€ Rate Limiting (HERE)
  â†“
Microservices
```

Why Gateway?

 Single choke point
 No duplication
 Protects all downstream services

---

# 3ï¸âƒ£ Rate Limiting in Spring Cloud Gateway (High Level)

Spring Cloud Gateway uses a Filter-based model.

```
Incoming Request
   â†“
Global Filters
   â†“
Route Filters (RateLimiter filter here)
   â†“
Forward to Service
```

Rate limiting is implemented via:

```
GatewayFilter â†’ RateLimiter â†’ Redis
```

---

# 4ï¸âƒ£ Core Components Involved (VERY IMPORTANT)

### 1ï¸âƒ£ GatewayFilter

Intercepts request before routing.

### 2ï¸âƒ£ RateLimiter Interface

```java
public interface RateLimiter<C> {
    Mono<Response> isAllowed(String routeId, String key);
}
```

### 3ï¸âƒ£ KeyResolver

Decides WHO is being rate limited.

Examples:

 IP address
 User ID
 API key
 JWT claim

### 4ï¸âƒ£ Redis

Stores counters atomically.

âš ï¸ Redis is mandatory in production
(In-memory rate limiting is unsafe in distributed systems)

---

# 5ï¸âƒ£ Algorithm Used: Token Bucket (Default)

SCG uses Token Bucket algorithm

### Token Bucket explained

 Bucket has capacity (burst)
 Tokens refill at a fixed rate
 Each request consumes 1 token
 If no token â†’ âŒ 429 Too Many Requests

---

### Parameters

| Property        | Meaning                        |
| --------------- | ------------------------------ |
| replenishRate   | Tokens added per second        |
| burstCapacity   | Max bucket size                |
| requestedTokens | Tokens per request (usually 1) |

---

# 6ï¸âƒ£ Step-by-Step Implementation (Complete)

## âœ… Step 1: Add Dependencies

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-gateway</artifactId>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
</dependency>
```

---

## âœ… Step 2: Configure Redis

```yaml
spring:
  redis:
    host: localhost
    port: 6379
```

Redis is used for:

 Atomic increments
 Cross-instance consistency

---

## âœ… Step 3: Define a KeyResolver

### Example: IP-based Rate Limiting

```java
@Bean
public KeyResolver ipKeyResolver() {
    return exchange ->
        Mono.just(
            exchange.getRequest()
                    .getRemoteAddress()
                    .getAddress()
                    .getHostAddress()
        );
}
```

---

### Example: User-based Rate Limiting (JWT)

```java
@Bean
public KeyResolver userKeyResolver() {
    return exchange -> Mono.just(
        exchange.getRequest()
            .getHeaders()
            .getFirst("X-USER-ID")
    );
}
```

ğŸ‘‰ This decides who gets limited

---

## âœ… Step 4: Configure Rate Limiter Bean

```java
@Bean
public RedisRateLimiter redisRateLimiter() {
    return new RedisRateLimiter(
        10, // replenishRate (tokens/sec)
        20  // burstCapacity
    );
}
```

Meaning:

 10 requests/sec steady
 Can burst up to 20 requests

---

## âœ… Step 5: Apply Rate Limiting to Routes

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: user-service
          uri: lb://USER-SERVICE
          predicates:
            - Path=/users/
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 5
                redis-rate-limiter.burstCapacity: 10
                key-resolver: "#{@ipKeyResolver}"
```

---

# 7ï¸âƒ£ What Happens at Runtime (Exact Flow)

Letâ€™s trace ONE request:

```
Request â†’ Gateway
  â†“
Route matched
  â†“
RequestRateLimiterFilter
  â†“
KeyResolver â†’ "192.168.1.10"
  â†“
RedisRateLimiter
  â†“
Redis Lua Script (atomic)
  â†“
Tokens available?
   â”œâ”€ YES â†’ Forward request
   â””â”€ NO  â†’ HTTP 429
```

---

# 8ï¸âƒ£ Redis Internals (Very Important)

SCG executes a Lua script inside Redis:

 Atomic increment
 No race conditions
 No distributed locks

Redis keys look like:

```
request_rate_limiter.{routeId}.{key}
```

Example:

```
request_rate_limiter.user-service.192.168.1.10
```

---

# 9ï¸âƒ£ Handling Rate Limit Exceeded

### Default Response

```
HTTP/1.1 429 Too Many Requests
```

### Customize response

```yaml
spring:
  cloud:
    gateway:
      default-filters:
        - name: RequestRateLimiter
```

Or add custom GlobalFilter for response body.

---

# ğŸ”Ÿ Advanced Patterns (Production Grade)

## ğŸ”¥ 1. Different Limits per API

```yaml
/users/   â†’ 10 rps
/orders/  â†’ 2 rps
/payments/ â†’ 1 rps
```

---

## ğŸ”¥ 2. Tier-based Limits

 Free user â†’ 5 rps
 Premium â†’ 50 rps

KeyResolver extracts user tier.

---

## ğŸ”¥ 3. Sliding Window (Custom)

Default is token bucket.
For strict windows â†’ custom Redis script.

---

## ğŸ”¥ 4. Combine with Circuit Breaker

```text
Rate Limit â†’ Retry â†’ Circuit Breaker
```

Correct order:

```
RateLimiter â†’ CircuitBreaker â†’ Retry âŒ
RateLimiter â†’ Retry â†’ CircuitBreaker âœ…
```

---

# 1ï¸âƒ£1ï¸âƒ£ Common Production Mistakes (READ THIS)

âŒ In-memory rate limiting
âŒ Per-pod Redis
âŒ Using IP in Kubernetes (NAT issue)
âŒ No burst capacity
âŒ Rate limiting after auth

---

# 1ï¸âƒ£2ï¸âƒ£ Best Practices (Zepto-Scale)

âœ” Always Redis-backed
âœ” Use user-based keys (JWT / API key)
âœ” Separate limits for read/write APIs
âœ” Monitor Redis latency
âœ” Expose rate-limit headers

---

# 1ï¸âƒ£3ï¸âƒ£ Rate Limiting vs Throttling vs Quotas

| Term          | Meaning           |
| ------------- | ----------------- |
| Rate limiting | Requests per time |
| Throttling    | Slow down traffic |
| Quota         | Fixed total usage |

SCG supports rate limiting, not quotas (needs custom impl).

---

# 1ï¸âƒ£4ï¸âƒ£ Final Summary (Straight Talk)

 Rate limiting in SCG is filter-based
 Uses Redis + Token Bucket
 KeyResolver decides who
 RedisRateLimiter decides how much
 Protects entire system before damage

---

If you want next:

 ğŸ”¥ Custom Redis Lua rate limiter
 ğŸ”¥ JWT-based tiered limits
 ğŸ”¥ Rate limit headers (X-RateLimit-Remaining)
 ğŸ”¥ Rate limiting in Kubernetes ingress vs SCG

Just say the word ğŸ‘Œ
