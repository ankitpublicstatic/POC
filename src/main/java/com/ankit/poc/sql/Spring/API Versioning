API Versioning is a **strategy to evolve your APIs without breaking existing clients** (mobile apps, web apps, 3rd-party consumers).
In real production systemsâ€”especially microservices like the ones youâ€™ve been asking aboutâ€”**API versioning is non-negotiable**.

Iâ€™ll explain this **from fundamentals â†’ Spring Boot implementations â†’ real production trade-offs**.

---

## 1ï¸âƒ£ Why API Versioning is Needed (Real-World Problem)

Imagine you already exposed this API:

```http
GET /users/123
```

Response (v1):

```json
{
  "id": 123,
  "name": "Ankit"
}
```

Now business asks:

* Add `email`
* Rename `name` â†’ `fullName`
* Remove `id` (security reasons)

If you **change the response directly**, all existing clients break.

ğŸ‘‰ **API Versioning allows old clients to keep working while new clients move forward.**

---

## 2ï¸âƒ£ What is API Versioning?

> **API Versioning = Maintaining multiple versions of an API contract simultaneously**

Each version:

* Has its own request/response structure
* Evolves independently
* Has a lifecycle (active â†’ deprecated â†’ removed)

---

## 3ï¸âƒ£ Common API Versioning Strategies (Industry Standard)

### âœ… 1. URI Versioning (Most Popular)

```http
/api/v1/users
/api/v2/users
```

âœ” Simple
âœ” Cache-friendly
âœ” Works well with API Gateways
âŒ Version becomes part of URL

---

### âœ… 2. Request Header Versioning

```http
GET /users
X-API-VERSION: 1
```

âœ” Clean URLs
âŒ Harder to debug
âŒ Not cache-friendly

---

### âœ… 3. Media Type / Accept Header Versioning

```http
Accept: application/vnd.company.users.v1+json
```

âœ” REST-pure
âŒ Very complex
âŒ Rare in practice

---

### âŒ 4. Query Parameter Versioning (Not recommended)

```http
/users?version=1
```

âŒ Breaks caching
âŒ Easy to misuse

---

## 4ï¸âƒ£ How API Versioning is Done in Spring Boot (Deep Dive)

---

# ğŸ…°ï¸ URI Versioning (Most Used in Spring Boot)

### Controller Structure

```java
@RestController
@RequestMapping("/api/v1/users")
public class UserControllerV1 {

    @GetMapping("/{id}")
    public UserV1 getUser(@PathVariable Long id) {
        return new UserV1(id, "Ankit");
    }
}
```

```java
@RestController
@RequestMapping("/api/v2/users")
public class UserControllerV2 {

    @GetMapping("/{id}")
    public UserV2 getUser(@PathVariable Long id) {
        return new UserV2(id, "Ankit Kumar Singh", "ankit@email.com");
    }
}
```

### DTOs per Version (Very Important)

```java
public class UserV1 {
    private Long id;
    private String name;
}
```

```java
public class UserV2 {
    private Long id;
    private String fullName;
    private String email;
}
```

âœ… **Never reuse DTOs across versions**
This is the #1 mistake in real projects.

---

# ğŸ…±ï¸ Header-Based Versioning in Spring Boot

### Controller

```java
@RestController
@RequestMapping("/api/users")
public class UserController {

    @GetMapping(value = "/{id}", headers = "X-API-VERSION=1")
    public UserV1 getUserV1(@PathVariable Long id) {
        return new UserV1(id, "Ankit");
    }

    @GetMapping(value = "/{id}", headers = "X-API-VERSION=2")
    public UserV2 getUserV2(@PathVariable Long id) {
        return new UserV2(id, "Ankit Kumar Singh", "ankit@email.com");
    }
}
```

Request:

```http
GET /api/users/1
X-API-VERSION: 2
```

---

# ğŸ…² Media Type Versioning (Advanced)

```java
@GetMapping(
    value = "/{id}",
    produces = "application/vnd.company.users.v1+json"
)
```

Rarely used unless youâ€™re building **public APIs** (Stripe-style).

---

## 5ï¸âƒ£ Where Versioning Should NOT Be Done

âŒ Database schema
âŒ Service layer
âŒ Repository layer

âœ… **Versioning belongs to API contract layer only**

Service layer should be **version-agnostic**:

```java
public UserDomain getUser(Long id);
```

Mapping happens at controller or mapper level.

---

## 6ï¸âƒ£ API Versioning with API Gateway (Real Production)

In microservices:

```http
/api/v1/orders â†’ Order Service
/api/v2/orders â†’ Order Service
```

Gateway handles:

* Routing
* Version deprecation
* Canary rollout

Example (Spring Cloud Gateway):

```yaml
routes:
  - id: order-v1
    uri: lb://order-service
    predicates:
      - Path=/api/v1/orders/**
```

---

## 7ï¸âƒ£ Backward Compatibility Rules (VERY IMPORTANT)

You **can**:

* Add new fields
* Add optional headers
* Add new endpoints

You **cannot**:

* Remove fields
* Rename fields
* Change data types
* Change semantics

Breaking change â‡’ **New API version**

---

## 8ï¸âƒ£ Deprecation Strategy (Production Grade)

1. Mark old version as deprecated

```java
@Deprecated
@RestController
@RequestMapping("/api/v1/users")
```

2. Send warning header

```http
Deprecation: true
Sunset: 2025-06-30
```

3. Monitor usage
4. Remove after agreed timeline

---

## 9ï¸âƒ£ Versioning vs Feature Flags (Donâ€™t Confuse)

| Concern              | Use            |
| -------------------- | -------------- |
| Contract change      | API Versioning |
| Behavior change      | Feature Flags  |
| A/B testing          | Feature Flags  |
| Client compatibility | API Versioning |

---

## ğŸ”Ÿ Real Industry Recommendation (What Companies Actually Use)

| Company                | Strategy            |
| ---------------------- | ------------------- |
| Amazon                 | URI Versioning      |
| Netflix                | URI + Gateway       |
| Uber                   | URI                 |
| Stripe                 | Header / Media Type |
| Internal Microservices | URI                 |

ğŸ‘‰ **Use URI Versioning unless you have a strong reason not to.**

---

## 11ï¸âƒ£ Typical Folder Structure (Clean Architecture)

```
controller/
 â”œâ”€â”€ v1/
 â”‚    â””â”€â”€ UserControllerV1
 â””â”€â”€ v2/
      â””â”€â”€ UserControllerV2

dto/
 â”œâ”€â”€ v1/
 â””â”€â”€ v2/

service/
repository/
```

---

## ğŸ”š Final Takeaway

> **API Versioning protects clients, enables evolution, and avoids production disasters.**

If you want, next I can explain:

* ğŸ”¥ **How to migrate clients from v1 â†’ v2**
* ğŸ”¥ **How versioning works with Swagger / OpenAPI**
* ğŸ”¥ **How Netflix/Zepto-scale systems sunset APIs**

Just tell me ğŸ‘
