Perfect topic üëç
This is **core Spring + JVM + AOP internals**, and many production bugs come from misunderstanding this.

I‚Äôll explain this in **layers**:

1. **What a proxy is**
2. **JDK Dynamic Proxy (interface-based)**
3. **CGLIB Proxy (class-based)**
4. **How Spring chooses**
5. **Real production pitfalls**
6. **Comparison table**
7. **Interview-ready summary**

---

# 1Ô∏è‚É£ What is a Proxy (in Spring)?

A **proxy** is an **object that wraps another object** and intercepts method calls.

```text
Caller ‚Üí Proxy ‚Üí Target Object
```

Spring uses proxies for:

* `@Transactional`
* `@Cacheable`
* `@Async`
* `@Retryable`
* `@CircuitBreaker`
* Security checks

---

# 2Ô∏è‚É£ JDK Dynamic Proxy (Interface-Based)

### What it is

Built into Java (`java.lang.reflect.Proxy`).

It creates a class **at runtime** that:

* Implements one or more interfaces
* Delegates calls to an `InvocationHandler`

---

## 2.1 How it works internally

```java
PaymentService proxy =
    (PaymentService) Proxy.newProxyInstance(
        PaymentService.class.getClassLoader(),
        new Class[]{PaymentService.class},
        new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) {
                // before
                Object result = method.invoke(target, args);
                // after
                return result;
            }
        }
    );
```

üëâ JVM generates a class like:

```java
class $Proxy12 implements PaymentService {
    public void pay() {
        handler.invoke(this, payMethod, args);
    }
}
```

---

## 2.2 Key characteristics

| Feature             | JDK Proxy               |
| ------------------- | ----------------------- |
| Requires interface  | ‚úÖ                       |
| Proxy type          | Implements interface    |
| Inheritance         | `extends Proxy`         |
| Method interception | Via `InvocationHandler` |
| Performance         | Fast (JIT optimized)    |
| Final methods       | ‚ùå Cannot intercept      |
| Self-invocation     | ‚ùå Not intercepted       |

---

## 2.3 Why Spring prefers JDK Proxy

‚úî Clean separation
‚úî No bytecode libraries
‚úî Safe
‚úî Simple

That‚Äôs why:

```java
@Autowired
PaymentService paymentService;
```

is best practice.

---

# 3Ô∏è‚É£ CGLIB Proxy (Class-Based)

### What it is

Uses **bytecode generation** (CGLIB / ASM).

Creates a **subclass of the target class** at runtime.

---

## 3.1 How it works internally

```java
class PaymentService$$EnhancerBySpringCGLIB
    extends PaymentService {

    @Override
    public void pay() {
        // before
        super.pay();
        // after
    }
}
```

No interface required.

---

## 3.2 Key characteristics

| Feature            | CGLIB                   |
| ------------------ | ----------------------- |
| Requires interface | ‚ùå                       |
| Proxy type         | Subclass                |
| Final classes      | ‚ùå Cannot proxy          |
| Final methods      | ‚ùå Cannot intercept      |
| Constructors       | Called                  |
| Performance        | Slightly slower startup |
| Bytecode lib       | Yes                     |

---

## 3.3 When Spring uses CGLIB automatically

* No interface present
* `proxyTargetClass = true`
* `@Configuration` classes
* `@Autowired` concrete class

---

# 4Ô∏è‚É£ How Spring Chooses Between Them

### Default rule

```text
If interface exists ‚Üí JDK Proxy
Else ‚Üí CGLIB
```

---

### Forcing CGLIB

```java
@EnableTransactionManagement(proxyTargetClass = true)
```

or

```properties
spring.aop.proxy-target-class=true
```

---

# 5Ô∏è‚É£ VERY IMPORTANT: Self-Invocation Problem üö®

```java
@Service
class OrderService {

    @Transactional
    public void placeOrder() {
        saveOrder(); // ‚ùå NOT intercepted
    }

    @Transactional
    public void saveOrder() {
        // no transaction!
    }
}
```

### Why?

Call path:

```text
this.placeOrder() ‚Üí this.saveOrder()
```

‚ùå Proxy is bypassed

### Solution

‚úî Move method to another bean
‚úî Inject self-proxy
‚úî Use AspectJ

---

# 6Ô∏è‚É£ Real Production Pitfalls (Common Bugs)

---

## 6.1 `@Transactional` not working

‚ùå Method is:

* `private`
* `final`
* Called internally
* Not in interface (JDK proxy case)

---

## 6.2 `ClassCastException`

```java
OrderServiceImpl impl = (OrderServiceImpl) orderService;
```

Fails for JDK Proxy.

‚úî Always cast to interface.

---

## 6.3 `final` methods

```java
final void pay() {}
```

‚ùå Cannot be intercepted by either proxy.

---

# 7Ô∏è‚É£ JDK Proxy vs CGLIB ‚Äì Comparison Table

| Feature                      | JDK Proxy | CGLIB          |
| ---------------------------- | --------- | -------------- |
| Interface required           | ‚úÖ         | ‚ùå              |
| Proxy extends                | `Proxy`   | Target class   |
| Intercepts interface methods | ‚úÖ         | ‚úÖ              |
| Intercepts class methods     | ‚ùå         | ‚úÖ              |
| Final class/method           | ‚ùå         | ‚ùå              |
| Memory footprint             | Low       | Higher         |
| Startup time                 | Fast      | Slower         |
| Recommended                  | ‚úÖ         | ‚ö†Ô∏è When needed |

---

# 8Ô∏è‚É£ Interview One-Liners üß†

* **JDK proxy uses interfaces and InvocationHandler**
* **CGLIB creates subclass using bytecode**
* **Spring prefers JDK proxies**
* **Final methods can‚Äôt be proxied**
* **Self-invocation bypasses proxies**

---

# 9Ô∏è‚É£ When to Use What (Best Practice)

‚úî Always define **service interfaces**
‚úî Inject by interface
‚úî Avoid `final` methods on beans
‚úî Avoid self-invocation
‚úî Use CGLIB only if required

---

If you want next:

* Bytecode dump of CGLIB proxy
* Why `@Configuration` always uses CGLIB
* AspectJ vs Proxy-based AOP
* Performance benchmark

Just tell me üî•
