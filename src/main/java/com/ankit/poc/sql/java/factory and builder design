Perfect üëå ‚Äî let‚Äôs now go **step-by-step** through **Factory** and **Builder** design patterns in Java ‚Äî comparing them with **Singleton**, and showing when, why, and how to use each (with real-world code examples).

---

# üß± 1Ô∏è‚É£ Factory Design Pattern

### üéØ Intent

> **Factory Pattern** is used to create objects **without exposing the creation logic** to the client.
> The client just asks the factory for an object, and the factory decides which concrete class to instantiate.

### üß† Analogy

Think of a **Car Factory** ‚Äî you order a car by type ("SUV", "Sedan") and the factory gives you one.
You don‚Äôt care *how* it‚Äôs built.

---

### ‚úÖ Example

```java
// Step 1: Create a common interface
public interface Shape {
    void draw();
}

// Step 2: Implement concrete classes
public class Circle implements Shape {
    public void draw() {
        System.out.println("Drawing Circle");
    }
}

public class Square implements Shape {
    public void draw() {
        System.out.println("Drawing Square");
    }
}

// Step 3: Create a Factory class
public class ShapeFactory {
    public static Shape getShape(String type) {
        if ("CIRCLE".equalsIgnoreCase(type)) {
            return new Circle();
        } else if ("SQUARE".equalsIgnoreCase(type)) {
            return new Square();
        }
        return null;
    }
}

// Step 4: Client code
public class FactoryPatternTest {
    public static void main(String[] args) {
        Shape shape1 = ShapeFactory.getShape("CIRCLE");
        shape1.draw();

        Shape shape2 = ShapeFactory.getShape("SQUARE");
        shape2.draw();
    }
}
```

### üí¨ Output:

```
Drawing Circle
Drawing Square
```

### üí° Key Points

* **Encapsulates object creation** logic.
* Promotes **loose coupling** ‚Äî client depends on interface, not concrete class.
* Great for **switchable implementations** (e.g., different payment gateways).

---

# üèóÔ∏è 2Ô∏è‚É£ Builder Design Pattern

### üéØ Intent

> **Builder Pattern** helps create **complex objects step-by-step**, especially when there are **many optional parameters**.

### üß† Analogy

Think of building a **burger at McDonald‚Äôs** ‚Äî you choose bread, patty, sauce, etc.
Builder lets you construct the object gradually, keeping code readable and flexible.

---

### ‚úÖ Example

```java
// Step 1: Product class
public class User {
    private String firstName;   // required
    private String lastName;    // required
    private int age;            // optional
    private String phone;       // optional
    private String address;     // optional

    // Step 2: Static nested Builder class
    public static class Builder {
        private String firstName;
        private String lastName;
        private int age;
        private String phone;
        private String address;

        public Builder(String firstName, String lastName) {
            this.firstName = firstName;
            this.lastName = lastName;
        }

        public Builder age(int age) {
            this.age = age;
            return this;
        }

        public Builder phone(String phone) {
            this.phone = phone;
            return this;
        }

        public Builder address(String address) {
            this.address = address;
            return this;
        }

        public User build() {
            User user = new User();
            user.firstName = this.firstName;
            user.lastName = this.lastName;
            user.age = this.age;
            user.phone = this.phone;
            user.address = this.address;
            return user;
        }
    }

    @Override
    public String toString() {
        return firstName + " " + lastName + " (" + age + ") - " + phone + " - " + address;
    }
}

// Step 3: Client code
public class BuilderPatternTest {
    public static void main(String[] args) {
        User user = new User.Builder("Ankit", "Kumar")
                        .age(30)
                        .phone("9999999999")
                        .address("Pune")
                        .build();

        System.out.println(user);
    }
}
```

### üí¨ Output:

```
Ankit Kumar (30) - 9999999999 - Pune
```

### üí° Key Points

* Solves **telescoping constructor** problem.
* Enhances **readability** and **immutability**.
* Often used for **DTOs**, **configuration objects**, and **HTTP request builders**.

---

# ‚öñÔ∏è 3Ô∏è‚É£ Comparing Singleton, Factory, and Builder

| Pattern       | Purpose                               | Object Creation Style               | Example Use              |
| ------------- | ------------------------------------- | ----------------------------------- | ------------------------ |
| **Singleton** | Only one instance globally            | Controlled access (`getInstance()`) | Logger, Cache            |
| **Factory**   | Creates objects from common interface | Based on input/type                 | ShapeFactory, DAOFactory |
| **Builder**   | Step-by-step construction             | Chain methods ‚Üí `build()`           | POJOs with many fields   |

---

# üöÄ 4Ô∏è‚É£ Real-World Usage Together

You can even combine them:

* A **Singleton Factory** (only one instance of factory in the app).
* A **Factory** that returns different **Builders** for different products.

Example:

```java
public class NotificationFactory {

    private static final NotificationFactory INSTANCE = new NotificationFactory();

    private NotificationFactory() {}

    public static NotificationFactory getInstance() {
        return INSTANCE;
    }

    public NotificationBuilder getBuilder(String type) {
        if ("EMAIL".equalsIgnoreCase(type)) return new EmailNotificationBuilder();
        else if ("SMS".equalsIgnoreCase(type)) return new SmsNotificationBuilder();
        return null;
    }
}
```

Here the **Factory** is a **Singleton**, and it returns **Builder** objects.
That‚Äôs how patterns complement each other in enterprise systems.

---

Would you like me to show **a real-world enterprise example** combining all three (Singleton + Factory + Builder) in a single workflow (like building a configurable Notification Service or API client)?
